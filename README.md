# asynq: run commands asynchronously using `ts(1)`

This tool is intended to enable launching long-running processes
asynchronously, and collecting the output and return code on a subsequent run.
To facilitate this, this script uses the `ts(1)` task spooler utility,
which employs a queuing system to run a process in the background as a *job*.

This script was developed after I found an example
[i3status-rust](https://github.com/greshake/i3status-rust)
custom block I was using to ping a remote server as an indicator of wi-fi
connection quality would pause the entire status bar for 4 seconds or so
while it ran.

## Usage

```sh
asynq.sh COMMAND [ARG, ...]
```

For programs calling `asynq.sh` repeatedly, you'll want to determine an
interval between calls that works for your use case, based on expectations of
the duration of the command and how 'fresh' you'd like the output for the
consuming application to be.

By default, if one or more jobs is pending at the time `asynq.sh` runs, no
additional job will be launched. This behaviour can be modified by setting
`ASYNC_PENDING_JOBS_MIN` to a value higher than `0` in your environment before
calling `async.sh`.

## Simplified Processing Overview

1. The script uses the user's `uid` and a hash of the full command line to
generate a unique socket name for `ts` to use for jobs for this command line.

1. The script checks to see if there are results for a previous job waiting,
and if so captures those to output later.

1. It then checks if the number of pending jobs is greater than or equal to
the pending jobs minimum, and if not, launches a new instance of the job.

1. If a previous job's output was waiting, the script outputs that, and exits
with the return code of the corresponding run.

## Examples

### i3status-rust custom block command to output round trip time with state

I call this with an interval of 5 seconds.

```sh
asynq_out=$(asynq.sh ping -w 10 -c 4 1.1.1.1); asynq_res=$?; rtt_ms=$(echo "$asynq_out" | tail -n1 | cut -d'/' -f5); state='Critical'; if [[ $asynq_res -ne 0 ]]; then text="timeout"; else rtt_int=$(printf '%.0f' $rtt_ms); if (($rtt_int>0 && $rtt_int<=50)); then state='Idle'; elif (($rtt_int>50 && $rtt_int<=100)); then state='Good'; elif (($rtt_int>100 && $rtt_int<=200)); then state='Warning'; fi; text="$(printf '%0.2f' $rtt_ms) ㎳"; fi; echo "{\"icon\":\"ping\",\"state\":\"$state\",\"text\":\"$text\"}"
```

## Caveats

On my system at least, the filenames generated by the `ts` utility for temporary
job error output files have escape characters. The error output filename is
supposed to be the same as the standard output filename, except with a `.e`
extension. This may be a `ts` bug.

```sh
/tmp/ts-out.LDkLMK
/tmp/ts-out.LDkLMY^?.e
```
